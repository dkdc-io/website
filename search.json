[
  {
    "objectID": "posts/what-is-dkdc/index.html",
    "href": "posts/what-is-dkdc/index.html",
    "title": "launching ‘dkdc-io’",
    "section": "",
    "text": "A decade-long journey back home.\nNearly a decade ago, I started “DKDC LLC” not far from where I am today."
  },
  {
    "objectID": "posts/what-is-dkdc/index.html#why-dkdc",
    "href": "posts/what-is-dkdc/index.html#why-dkdc",
    "title": "launching ‘dkdc-io’",
    "section": "why “DKDC”?",
    "text": "why “DKDC”?\nI didn’t need to start a company, but I wanted to. I was working with a local company to prototype a device for testing in a hospital. Ostensibly a limited liability company (LLC) would limit my liability, but there was effectively no risk in my work. The real appeal was in learning the process and being able to say “I started a company”.\n\n“I started a company!”\n“Oh yeah? What’s it called?”\n“DKDC LLC.”\n“What does DKDC stand for?”\n“Don’t know, don’t care.”"
  },
  {
    "objectID": "posts/what-is-dkdc/index.html#branding",
    "href": "posts/what-is-dkdc/index.html#branding",
    "title": "launching ‘dkdc-io’",
    "section": "branding",
    "text": "branding\nMy full name is relatively common and I found “dkdc” to be a useful, unique suffix for online accounts. It’s bland, neutral, and doesn’t really mean anything. It was a good fit a decade ago for a company that didn’t really do anything and it’s been a good fit since for my usernames and personal branding since.\n\n\n\n\n\n\nWarning\n\n\n\n\n\n“dkdc” is very difficult to understand over the phone."
  },
  {
    "objectID": "posts/what-is-dkdc/index.html#starting-dkdc-io",
    "href": "posts/what-is-dkdc/index.html#starting-dkdc-io",
    "title": "launching ‘dkdc-io’",
    "section": "starting “dkdc-io”",
    "text": "starting “dkdc-io”\n\n“reincarnated”\n\nAs of publishing this post, “dkdc-io” is nothing more than an idea and a GitHub organization with some nascent code. It’s intended as a bland, neutral, and unassuming home for useful code that can do things for me (and perhaps others). Software for me. A startup in a box. A decade of learnings?"
  },
  {
    "objectID": "posts/fast-simple-python/index.html",
    "href": "posts/fast-simple-python/index.html",
    "title": "fast, full-stack Python (uv & Docker)",
    "section": "",
    "text": "Using uv and Docker to develop and deploy simple, scalable, full-stack Python applications.\n\nIn this post, we’ll look at my Dockerfile:\n# dkdc Dockerfile\nFROM ghcr.io/astral-sh/uv:latest AS uv\nFROM python:3.12-slim\n# set the environment variables\nENV PATH=/root/.local/bin:$PATH\n# set the working directory\nWORKDIR /app\n# copy the files\nCOPY readme.md /app/readme.md\nCOPY pyproject.toml /app/pyproject.toml\nCOPY src /app/src\n# install the Python packages\nRUN --mount=type=cache,target=/root/.cache/uv \\\n    --mount=from=uv,source=/uv,target=./uv \\\n    ./uv pip install '.' --system --upgrade\nI use it to develop simple, scalable, full-stack Python applications built with:\n\nTyper: CLI\nIbis: table management and queries\n\nSQLite and/or Postgres: OLTP database\nDuckDB: OLAP database (views on top of the OLTP tables)\n\nShiny for Python: GUI\n\nPlotly: plots\n\n\nThen, deploy them with ease (and minimal build times) locally, on a Raspberry Pi, and on a cloud VM. Of course, other open source software and Python packages are used along the way (and you can use whatever you like!).\nSome miscellaneous notes:\n\norder: the Dockefile is ordered so that frequently changing parts are toward the bottom\ncache: the big point is the caching line, which I stole from somewhere (here?)\npyproject.toml: the pyproject.toml is needed as it defines the installation of the package (and CLI)\nreadme.md: the readme.md is needed because it’s referenced in the pyproject.toml\nsrc: this is the source code, in something like src/my_package\npinning verions: in general I’m not pinning (or using a uv lockfile), but I would obviously recommend doing so for production workloads and having a process for updating dependencies\nsystem installation: we use system Python instead of creating a Python virtual environment (which uv makes easy) because we’re already in a virtual container (often itself in a virtual machine)\n\nCombining this with a few justfile commands makes development and deployment very easy. The simplicity of Python and tools that cover the full stack (CLI, database, GUI) make it a great choice for rapidly prototyping scalable applications.\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "dkdc.io",
    "section": "",
    "text": "Code by Cody.\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "about",
    "section": "",
    "text": "Things built for people.\nThe dkdc-io organization on GitHub was created in November 2024 to consolidate useful code in a free and open source manner. The priority is code components that can be composed to quickly develop and deploy scalable data applications.\nThe goals of the organization’s projects include:\nThese goals are largely achieved through the use of simplicity, Python, and “AI”."
  },
  {
    "objectID": "about.html#views-on-ai",
    "href": "about.html#views-on-ai",
    "title": "about",
    "section": "views on “AI”",
    "text": "views on “AI”\nArtificial intelligence (“AI”) is a science fiction (and now popular culture) term that anamorphosizes the reality of computers. Reframing language models as string processors that operate in useful ways simplifies the dynamic drastically.\n\nUser:\n“I want the phrase: ‘we often ____ AI as if it were human’, what’s the term?”\nChatGPT:\n“The term you’re looking for is ‘anthropomorphize’.\nSo the phrase would be: ‘We often anthropomorphize AI as if it were human.’”\n\nTechnology is good. I strongly prefer you send your code in a GitHub pull request from a computer instead a fax of a print out from your typerwriter. In either case, if you can’t vouch for the work you’re publishing, you’re doing it wrong.\n\nlanguage models and Python (and SQL)\nAbstractions: vim is a lot nicer than punching cards. Working with high-level programming languages is typically a lot more productive than working with assembly, though there will always be a place for programming languages at all levels of abstraction. For working with data (and machine learning), Python is a great choice and the clear winner by popularity (+ SQL)."
  },
  {
    "objectID": "about.html#views-on-simplicity",
    "href": "about.html#views-on-simplicity",
    "title": "about",
    "section": "views on simplicity",
    "text": "views on simplicity\nPython and SQL are arguably ubiquitous because of their simplicity. Both allow novice users to accomplish non-trivial work with minimal effort, while experienced professionals can use them to build complex systems."
  },
  {
    "objectID": "about.html#the-python-tech-stack",
    "href": "about.html#the-python-tech-stack",
    "title": "about",
    "section": "the Python tech stack",
    "text": "the Python tech stack\nPython is the user interface for programming at every level of the tech stack.\nFor now, this includes:\n\nTyper: CLI\nFastAPI: web server + continuous data ingestion and ETL (cron jobs)\nIbis: table management and queries\n\nSQLite and/or Postgres: OLTP database\nDuckDB: OLAP database (views on top of the OLTP tables)\n\nQuarto: website (static)\nShiny for Python: web app\n\nMeta-tools:\n\nuv: Python management\njustfile: task management\nDocker and Docker Compose: containerization\n\nInfrastructure:\n\nGitHub: code, CI/CD, etc.\nTBD: cloud provider (currently using raspberry pis and GCP)"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "posts",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nPython + Rust: a simple tutorial\n\n\n\n\n\n\nPython\n\n\nRust\n\n\n\n\n\n\n\n\n\nNov 27, 2024\n\n\nCody\n\n\n\n\n\n\n\n\n\n\n\n\nfast, simple, persistent state management with Python (Ibis)\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\nNov 26, 2024\n\n\nCody\n\n\n\n\n\n\n\n\n\n\n\n\nfast, full-stack Python (uv & Docker)\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\nNov 25, 2024\n\n\nCody\n\n\n\n\n\n\n\n\n\n\n\n\nlaunching ‘dkdc-io’\n\n\n\n\n\n\ndkdc-io\n\n\n\n\n\n\n\n\n\nNov 24, 2024\n\n\nCody\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "website",
    "section": "",
    "text": "website\nhttps://dkdc.io.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/pawz/index.html",
    "href": "posts/pawz/index.html",
    "title": "Python + Rust: a simple tutorial",
    "section": "",
    "text": "A Python interface to core functionality written in Rust.\nThis post is intended to provide a simple demonstration of a Python package that relies on core functionality written in Rust. You can view the source code on GitHub."
  },
  {
    "objectID": "posts/pawz/index.html#tools",
    "href": "posts/pawz/index.html#tools",
    "title": "Python + Rust: a simple tutorial",
    "section": "Tools",
    "text": "Tools\nIn addition to Python and Rust, we’ll use the following tools:\n\nGitHub: repository hosting\nGitHub CLI: interact with GitHub from the command line\njust: a command runner\nmise: a tool for managing dev environments (Python/Rust versions)\n\nFor generating and using Rust code in Python, we’ll use PyO3."
  },
  {
    "objectID": "posts/pawz/index.html#setting-up-the-project",
    "href": "posts/pawz/index.html#setting-up-the-project",
    "title": "Python + Rust: a simple tutorial",
    "section": "Setting up the project",
    "text": "Setting up the project\nWe’ll start with an overview of the project setup.\n\nPicking a name\nWe need a good name for our project. Ideally, this can match how the package on PyPI. I chose pawz because it was not taken, is short, and leans into what the demo package will do.\n\n\nLayout\nLet’s start by looking at the file tree for pawz:\n(venv) cody@dkdc pawz % tree\n./\n├── LICENSE\n├── dev-requirements.txt\n├── justfile\n├── pyproject.toml\n├── readme.md\n└── src/\n    ├── pawz/\n    │   └── __init__.py\n    └── pawz-core/\n        ├── Cargo.toml\n        ├── pyproject.toml\n        ├── readme.md\n        └── src/\n            ├── lib.rs\n            └── main.rs\n\n5 directories, 11 files\nThis setup is copied over from a private project, then modified to update the project name and reduce code to its minimal form.\n\n\nJustfile\nWe can look at the justfile – just is a command runner – to get a sense of the things we will be doing:\n# Justfile\n\n# load environment variables\nset dotenv-load\n\n# aliases\nalias fmt:=format\n\n# list justfile recipes\ndefault:\n    just --list\n\n# setup\nsetup:\n    @pip install -r dev-requirements.txt\n\n# build\nbuild:\n    just clean\n    @python -m build src/pawz-core\n    @python -m build\n\n# format\nformat:\n    @cargo fmt --manifest-path src/pawz-core/Cargo.toml\n    @ruff format .\n\n# install\ninstall:\n    @maturin dev -m src/pawz-core/Cargo.toml\n    @pip install --upgrade -e '.[all]'\n\n# uninstall\nuninstall:\n    @pip uninstall pawz pawz-core -y\n\n# release-test\nrelease-test:\n    just build\n    @twine upload --repository testpypi src/pawz-core/dist/* -u __token__ -p ${PYPI_TEST_TOKEN}\n    @twine upload --repository testpypi dist/* -u __token__ -p ${PYPI_TEST_TOKEN}\n\n# release\nrelease:\n    just build\n    @twine upload src/pawz-core/dist/* -u __token__ -p ${PYPI_TOKEN}\n    @twine upload dist/* -u __token__ -p ${PYPI_TOKEN}\n\n# clean\nclean:\n    @rm -r src/pawz-core/target || True\n    @rm -rf src/pawz-core/dist || True\n    @rm -rf dist || True\n\n\nPython and Rust sub-projects\nYou may have already noticed above we’re building and publishing two Python packages – pawz is a pure Python package that depends on pawz-core, a pure Rust package with Python bindings.\nYou can see the package definitions in the respective pyproject.tomls:\n\n\n\n\n\n\nImportant\n\n\n\nDue to the website’s exquisite theme, you may not be able to tell that below are two separate tabs.\n(this is no longer true after rehoming the post, but I’ll leave it in for posterity)\n\n\n\npawz: pure Pythonpawz-core: pure Rust with Python bindings\n\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[project]\nname = \"pawz\"\nversion = \"0.1.0\"\nauthors = [{ name = \"Cody\", email = \"cody@dkdc.dev\" }]\ndescription = \"a demo of Python + Rust\"\nreadme = \"readme.md\"\nrequires-python = \"&gt;=3.11\"\nclassifiers = [\n  \"Programming Language :: Python :: 3\",\n  \"License :: OSI Approved :: MIT License\",\n  \"Operating System :: OS Independent\",\n]\ndependencies = [\"pawz_core\"]\n\n[project.urls]\n\"Homepage\" = \"https://github.com/lostmygithubaccount/pawz\"\n\"Bug Tracker\" = \"https://github.com/lostmygithubaccount/pawz/issues\"\n\n\n[build-system]\nrequires = [\"maturin&gt;=1.5,&lt;2.0\"]\nbuild-backend = \"maturin\"\n\n[project]\nname = \"pawz_core\"\ndynamic = [\"version\"]\nauthors = [{ name = \"Cody\", email = \"cody@dkdc.dev\" }]\ndescription = \"pawz core functionality (Rust!)\"\nreadme = \"readme.md\"\nrequires-python = \"&gt;=3.11\"\nclassifiers = [\n  \"Programming Language :: Python :: 3\",\n  \"License :: OSI Approved :: MIT License\",\n  \"Operating System :: OS Independent\",\n]\ndependencies = []\n\n[tool.maturin]\nfeatures = [\"pyo3/extension-module\"]\n\n[project.urls]\n\"Homepage\" = \"https://github.com/lostmygithubaccount/pawz\"\n\"Bug Tracker\" = \"https://github.com/lostmygithubaccount/pawz/issues\"\n\n\n\nYou’ll notice the primary difference is the build tooling – hatchling for the pure-Python project versus maturin for the Rust project.\nWith pawz-core, the package version is specified in the Cargo.toml instead of the pyproject.toml – we’ll take a closer look at that later.\n\n\npawz\nLet’s setup our Python package pawz – to start, all you need is an __init__.py file in the correct subdirectory:\n# imports\nimport pawz_core as pc\n\n# exports\n__all__ = [\"pc\"]\nAll we’re doing at this point is making pawz_core available as a module from pawz. So, we can do something like:\nimport pawz as pz\n\npz.pc.open_pawz()\nWhere the open_pawz() method is defined in pawz_core. We haven’t done that yet, but will later.\n\n\npawz-core\nIn addition to the pyproject.toml above, we need a Cargo.toml to define the Rust project:\n[package]\nname = \"pawz_core\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\nname = \"pawz_core\"\ncrate-type = [\"cdylib\"]\n\n[dependencies]\npyo3 = \"0.21.1\"\nNotice the Python package’s version will match the version defined here.\nWe also need the lib.rs in the src/ directory defining the functionality and exposing it through the Python bindings:\nuse pyo3::prelude::*;\n//use pyo3::exceptions::PyValueError;\n//use pyo3::types::PyTuple;\n\n/// A Python module implemented in Rust.\n#[pymodule]\n#[allow(deprecated)]\nfn pawz_core(_py: Python, _m: &PyModule) -&gt; PyResult&lt;()&gt; {\n    Ok(())\n}\nNotice there’s nothing defined yet and a few things are commented out and prepended with an underscore to avoid the compiler complaining. However at this point, everything is fully functional – you can build pawz-core and pawz and import them.\n\n\n\n\n\n\nWhat about the main.rs?\n\n\n\n\n\nAs of writing, the main.rs is a simple hello world:\nfn main() {\n    println!(\"Hello, world!\");\n}\nYou don’t need the file, but I find it useful to easily try things out in Rust. For instance, you can import things from lib.rs and run them."
  },
  {
    "objectID": "posts/pawz/index.html#setup-the-python-environment",
    "href": "posts/pawz/index.html#setup-the-python-environment",
    "title": "Python + Rust: a simple tutorial",
    "section": "Setup the Python environment",
    "text": "Setup the Python environment\nLet’s take a look at the dev-requirements.txt:\n# python\nruff\nbuild\ntwine\n\n# rust\nmaturin\nruff is to format Python code, build is to build the Python packages, twine is to upload them to PyPI, and maturin is to build the Rust package with Python bindings. You can see the use of these tools above in the justfile.\n\nSetup a virtual Python environment\nYou should generally use one virtual environment per project. I use mise to manage Python (and Rust) versions, but you don’t have to. You can run:\n(venv) cody@dkdc pawz % python -m venv venv\n(venv) cody@dkdc pawz % source venv/bin/activate\nto create your virtual environment. At this point if you’ve installed just, you can run:\n(venv) cody@dkdc pawz % just setup\nThis will install the dev dependencies defined above.\n\n\nInstalling pawz and pawz-core\nYou can install pawz and pawz-core in local developer mode with:\n(venv) cody@dkdc pawz % just install\nNow you’re able to import pawz as pz!"
  },
  {
    "objectID": "posts/pawz/index.html#uploading-to-github",
    "href": "posts/pawz/index.html#uploading-to-github",
    "title": "Python + Rust: a simple tutorial",
    "section": "Uploading to GitHub",
    "text": "Uploading to GitHub\nThere are multiple ways to do this, but I prefer something like:\n(venv) cody@dkdc pawz % git init\n(venv) cody@dkdc pawz % gh repo create pawz --public --source .\n(venv) cody@dkdc pawz % git checkout -b main\n(venv) cody@dkdc pawz % git add .\n(venv) cody@dkdc pawz % git commit -m \"initial commit\"\n(venv) cody@dkdc pawz % git push --set-upstream origin/main\nNow, your code should be up on GitHub!"
  },
  {
    "objectID": "posts/pawz/index.html#publishing-to-pypi",
    "href": "posts/pawz/index.html#publishing-to-pypi",
    "title": "Python + Rust: a simple tutorial",
    "section": "Publishing to PyPI",
    "text": "Publishing to PyPI\nLet’s publish pawz and pawz-core to PyPI. First, you need to generate and place PyPI tokens in a .env file:\nPYPI_TOKEN = \"pypi-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\nPYPI_TEST_TOKEN = \"pypi-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\nThen run:\n(venv) cody@dkdc pawz % just release-test\n(venv) cody@dkdc pawz % just release"
  },
  {
    "objectID": "posts/pawz/index.html#doing-something",
    "href": "posts/pawz/index.html#doing-something",
    "title": "Python + Rust: a simple tutorial",
    "section": "Doing something",
    "text": "Doing something\nNow, let’s do something! We’ll write some core functionality in Rust. For this demonstration, we’ll just open up a hardcoded URL pointing to a YouTube video.\n\n\n\n\n\n\nImportant\n\n\n\nIn the pyproject.toml and Cargo.toml we should bump the version up so we can ship a new version later."
  },
  {
    "objectID": "posts/pawz/index.html#rust-edits",
    "href": "posts/pawz/index.html#rust-edits",
    "title": "Python + Rust: a simple tutorial",
    "section": "Rust edits",
    "text": "Rust edits\nWe need to add the open crate dependency in the Cargo.toml:\n[package]\nname = \"pawz_core\"\nversion = \"0.2.0\"\nedition = \"2021\"\n\n[lib]\nname = \"pawz_core\"\ncrate-type = [\"cdylib\"]\n\n[dependencies]\npyo3 = \"0.21.1\"\nopen = \"5.1.2\"\nThen edit lib.rs to create our function and add it to the Python module:\nuse open;\nuse pyo3::prelude::*;\n//use pyo3::exceptions::PyValueError;\n//use pyo3::types::PyTuple;\n\n#[pyfunction]\nfn open_pawz() {\n    let url = \"https://www.youtube.com/watch?v=gJ6slhwPp6E\";\n    open::that(url).unwrap();\n}\n\n/// A Python module implemented in Rust.\n#[pymodule]\n#[allow(deprecated)]\nfn pawz_core(_py: Python, m: &PyModule) -&gt; PyResult&lt;()&gt; {\n    m.add_function(wrap_pyfunction!(open_pawz, m)?)?;\n    Ok(())\n}\nNow if you import pawz_core, you can run pawz_core.open_pawz() from Python!\n\nPython edits\nNo edits to Python are needed – since pawz_core is available from pawz, we can just call pawz.pawz_core.open_pawz(). You might want something different, i.e. to abstract away the core library code, but this is fine for demonstration purposes.\n\n\nGit workflow\nFirst, we’ll check what we changed:\n\n\n\n\n\n\nNote\n\n\n\nI changed a bit more when I actually did this, reflected in some of the output below.\n\n\n(venv) cody@dkdc pawz % git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   pyproject.toml\n        modified:   src/pawz-core/Cargo.toml\n        modified:   src/pawz-core/src/lib.rs\n        modified:   src/pawz/__init__.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nCheckout a branch to commit our changes to:\n(venv) cody@dkdc pawz % git checkout -b add-something\nSwitched to a new branch 'add-something'\nEnsure we format our code (Rust and Python):\n(venv) cody@dkdc pawz % just fmt\n1 file left unchanged\nAdd our changes and commit them:\n(venv) cody@dkdc pawz % git add .\n(venv) cody@dkdc pawz % git commit -m \"add something\"\n[add-something 3e8727d] add something\n 4 files changed, 17 insertions(+), 5 deletions(-)\nThen create a PR on GitHub:\n(venv) cody@dkdc pawz % gh pr create\n? Where should we push the 'add-something' branch? lostmygithubaccount/pawz\n\nCreating pull request for add-something into main in lostmygithubaccount/pawz\n\n? Title add something\n? Body &lt;Received&gt;\n? What's next? Submit\nremote:\nremote:\nTo https://github.com/lostmygithubaccount/pawz.git\n * [new branch]      HEAD -&gt; add-something\nbranch 'add-something' set up to track 'origin/add-something'.\nhttps://github.com/lostmygithubaccount/pawz/pull/1\nAnd finally, merge the PR from the CLI:\n(venv) cody@dkdc pawz % gh pr merge\nMerging pull request lostmygithubaccount/pawz#1 (add something)\n? What merge method would you like to use? Squash and merge\n? Delete the branch locally and on GitHub? Yes\n? What's next? Submit\n✓ Squashed and merged pull request lostmygithubaccount/pawz#1 (add something)\nremote: Enumerating objects: 19, done.\nremote: Counting objects: 100% (19/19), done.\nremote: Compressing objects: 100% (6/6), done.\nremote: Total 10 (delta 3), reused 9 (delta 3), pack-reused 0\nUnpacking objects: 100% (10/10), 1.72 KiB | 586.00 KiB/s, done.\nFrom https://github.com/lostmygithubaccount/pawz\n * branch            main       -&gt; FETCH_HEAD\n   a866fd3..318bd89  main       -&gt; origin/main\nUpdating a866fd3..318bd89\nFast-forward\n pyproject.toml           |  2 +-\n src/pawz-core/Cargo.toml |  3 ++-\n src/pawz-core/src/lib.rs | 10 +++++++++-\n src/pawz/__init__.py     |  7 +++++--\n 4 files changed, 17 insertions(+), 5 deletions(-)\n✓ Deleted local branch add-something and switched to branch main\n✓ Deleted remote branch add-something\nNow our source code is updated. You can view this PR here, including the files changed."
  },
  {
    "objectID": "posts/pawz/index.html#updating-on-pypi",
    "href": "posts/pawz/index.html#updating-on-pypi",
    "title": "Python + Rust: a simple tutorial",
    "section": "Updating on PyPI",
    "text": "Updating on PyPI\nWith our code updated, we want to update our packages on PyPI. We simply run:\n(venv) cody@dkdc pawz % just release\nas before, shipping the new version that does something!"
  },
  {
    "objectID": "posts/pawz/index.html#conclusion",
    "href": "posts/pawz/index.html#conclusion",
    "title": "Python + Rust: a simple tutorial",
    "section": "Conclusion",
    "text": "Conclusion\nI hope this is helpful to someone setting up a Python package with core functionality written in Rust. Of course, there are many ways to do this but I find the above fairly clean."
  },
  {
    "objectID": "posts/fast-simple-state/index.html",
    "href": "posts/fast-simple-state/index.html",
    "title": "fast, simple, persistent state management with Python (Ibis)",
    "section": "",
    "text": "Using SQLite and DuckDB (via Ibis) to manage perisistent state in Python."
  },
  {
    "objectID": "posts/fast-simple-state/index.html#dkdc-state",
    "href": "posts/fast-simple-state/index.html#dkdc-state",
    "title": "fast, simple, persistent state management with Python (Ibis)",
    "section": "dkdc-state",
    "text": "dkdc-state\nIn this post, we’ll look at the what and why of dkdc-state:\n\nfrom dkdc_state import State, ibis\n\nibis.options.interactive = True\n\nstate = State()\nstate._clear() # for demonstration purposes, clear all tables\nstate\n\n&lt;dkdc_state.main.State at 0x107ed6ab0&gt;\n\n\nThe State class itself isn’t very interesting, but we extend it to implement a number of other stateful Python libraries. Looking at the source code:\n\n\nState class code code\nfrom website.utils import get_class_source\n\nget_class_source(State)\n\n\n                                                                                                                   \n class State:                                                                                                      \n     # initialization                                                                                              \n     def __init__(self, dbpath: str = \"data.db\"):                                                                  \n         self.dbpath = dbpath                                                                                      \n                                                                                                                   \n         self.wcon, self.rcon = self._cons()                                                                       \n                                                                                                                   \n     # reference implementation -- to be overridden                                                                \n     def _cons(self) -&gt; (ibis.BaseBackend, ibis.BaseBackend):                                                      \n         # create write connection                                                                                 \n         wcon = ibis.sqlite.connect(self.dbpath)                                                                   \n                                                                                                                   \n         # create tables in write connection                                                                       \n         ...                                                                                                       \n                                                                                                                   \n         # create read connection                                                                                  \n         rcon = ibis.duckdb.connect()                                                                              \n                                                                                                                   \n         # create tables in read connection                                                                        \n         for table_name in wcon.list_tables():                                                                     \n             rcon.read_sqlite(self.dbpath, table_name=table_name)                                                  \n                                                                                                                   \n         # return connections                                                                                      \n         return wcon, rcon                                                                                         \n                                                                                                                   \n     def _clear(self, table_names: str | list[str] = None):                                                        \n         # if table_names is None, clear all tables                                                                \n         table_names = self.wcon.list_tables() if table_names is None else table_names                             \n                                                                                                                   \n         # if table_names is a string, convert to a list                                                           \n         if isinstance(table_names, str):                                                                          \n             table_names = [table_names]                                                                           \n                                                                                                                   \n         # drop views and tables                                                                                   \n         for table_name in table_names:                                                                            \n             self.rcon.drop_view(table_name)                                                                       \n             self.wcon.drop_table(table_name)                                                                      \n                                                                                                                   \n         # reset connections (recreate tables)                                                                     \n         self.wcon, self.rcon = self._cons()                                                                       \n                                                                                                                   \n\n\n\nWe define a __init__ method that calls a _cons method that sets up a write connection (SQLite) and read connection (DuckDB) with Ibis. A standard _clear method is defined to drop the tables (and corresponding views). That’s it!\nTo create a fast, simple, persistent state management system we simply need to extend the State class, implement the table creation in the _cons method, and add methods to interact with the state.\n\ndkdc-todo\nLet’s look at dkdc-todo as an example:\n\nfrom dkdc_todo import Todo\n\ntodo = Todo(dbpath=\"data.db\")\ntodo\n\n&lt;dkdc_todo.main.Todo at 0x11732a180&gt;\n\n\nWe can view the table (and thus the schema):\n\ntodo.t()\n\n┏━━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n┃ idx          ┃ id     ┃ user_id ┃ subject ┃ body   ┃ priority ┃ status ┃ description ┃ labels        ┃\n┡━━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n│ timestamp(6) │ string │ string  │ string  │ string │ int64    │ string │ string      │ array&lt;string&gt; │\n└──────────────┴────────┴─────────┴─────────┴────────┴──────────┴────────┴─────────────┴───────────────┘\n\n\n\nThen append items to the table:\n\ntodo.append_todo(id=\"test\", user_id=None, subject=None, body=\"do your homework\")\n\n{'idx': datetime.datetime(2024, 11, 25, 17, 8, 43, 385111),\n 'id': 'test',\n 'user_id': None,\n 'subject': None,\n 'body': 'do your homework',\n 'priority': 100,\n 'status': None,\n 'description': None,\n 'labels': None}\n\n\nAt this point we see our record:\n\ntodo.t()\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┓\n┃ idx                        ┃ id     ┃ user_id ┃ subject ┃ body             ┃ priority ┃ status ┃ description ┃ labels ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━┩\n│ timestamp(6)               │ string │ string  │ string  │ string           │ int64    │ string │ string      │ array… │\n├────────────────────────────┼────────┼─────────┼─────────┼──────────────────┼──────────┼────────┼─────────────┼────────┤\n│ 2024-11-25 17:08:43.385111 │ test   │ NULL    │ NULL    │ do your homework │      100 │ NULL   │ NULL        │ NULL   │\n└────────────────────────────┴────────┴─────────┴─────────┴──────────────────┴──────────┴────────┴─────────────┴────────┘\n\n\n\nImportantly, dkdc-state tables are intended to be append-only. Once append_* (confusingly named here) is called, you must use update_* to update the record (with the same id).\nTo demonstrate this, let’s update that record:\n\ntodo.update_todo(id=\"test\", user_id=None, subject=None, body=\"do your homework!\")\n\n{'idx': datetime.datetime(2024, 11, 25, 17, 8, 43, 436369),\n 'id': 'test',\n 'user_id': None,\n 'subject': None,\n 'body': 'do your homework!',\n 'priority': 100,\n 'status': None,\n 'description': None,\n 'labels': None}\n\n\nThen view our table:\n\ntodo.t()\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┓\n┃ idx                        ┃ id     ┃ user_id ┃ subject ┃ body              ┃ priority ┃ status ┃ description ┃ labels ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━┩\n│ timestamp(6)               │ string │ string  │ string  │ string            │ int64    │ string │ string      │ array… │\n├────────────────────────────┼────────┼─────────┼─────────┼───────────────────┼──────────┼────────┼─────────────┼────────┤\n│ 2024-11-25 17:08:43.436369 │ test   │ NULL    │ NULL    │ do your homework! │      100 │ NULL   │ NULL        │ NULL   │\n└────────────────────────────┴────────┴─────────┴─────────┴───────────────────┴──────────┴────────┴─────────────┴────────┘\n\n\n\nThere’s only 1 row! The second rows is in there, the table code is just set to only show the latest version of each record.\nLet’s look at the underlying table:\n\ntodo.wcon.table(todo.todos_table_name)\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┓\n┃ idx                        ┃ id     ┃ user_id ┃ subject ┃ body              ┃ priority ┃ status ┃ description ┃ labels ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━┩\n│ timestamp                  │ string │ string  │ string  │ string            │ int64    │ string │ string      │ string │\n├────────────────────────────┼────────┼─────────┼─────────┼───────────────────┼──────────┼────────┼─────────────┼────────┤\n│ 2024-11-25 17:08:43.385111 │ test   │ NULL    │ NULL    │ do your homework  │      100 │ NULL   │ NULL        │ NULL   │\n│ 2024-11-25 17:08:43.436369 │ test   │ NULL    │ NULL    │ do your homework! │      100 │ NULL   │ NULL        │ NULL   │\n└────────────────────────────┴────────┴─────────┴─────────┴───────────────────┴──────────┴────────┴─────────────┴────────┘\n\n\n\nAnd we see both rows. You can add other convenience methods to the state class as needed:\n\ntodo.get_todo(id=\"test\")\n\n{'idx': datetime.datetime(2024, 11, 25, 17, 8, 43, 436369),\n 'id': 'test',\n 'user_id': None,\n 'subject': None,\n 'body': 'do your homework!',\n 'priority': 100,\n 'status': None,\n 'description': None,\n 'labels': None}\n\n\nTaking a look at the source code:\n\n\nTodo class code code\nget_class_source(Todo)\n\n\n                                                                                                                   \n class Todo(State):                                                                                                \n     def __init__(self, dbpath: str = None):                                                                       \n         if dbpath is None:                                                                                        \n             dbpath = os.path.join(get_dkdc_dir(), \"todo.db\")                                                      \n         super().__init__(dbpath=dbpath)                                                                           \n                                                                                                                   \n     def _cons(self) -&gt; (ibis.BaseBackend, ibis.BaseBackend):                                                      \n         # create write connection                                                                                 \n         wcon = ibis.sqlite.connect(self.dbpath)                                                                   \n                                                                                                                   \n         # create tables in write connection                                                                       \n         ## todos data                                                                                             \n         self.todos_table_name = \"todos\"                                                                           \n         schema = ibis.schema(                                                                                     \n             {                                                                                                     \n                 \"idx\": dt.timestamp,                                                                              \n                 \"id\": str,                                                                                        \n                 \"user_id\": str,                                                                                   \n                 \"subject\": str,                                                                                   \n                 \"body\": str,                                                                                      \n                 \"priority\": int,                                                                                  \n                 \"status\": str,                                                                                    \n                 \"description\": str,                                                                               \n                 \"labels\": str,  # comma-separated list of labels                                                  \n             }                                                                                                     \n         )                                                                                                         \n         if self.todos_table_name not in wcon.list_tables():                                                       \n             wcon.create_table(self.todos_table_name, schema=schema)                                               \n                                                                                                                   \n         # create read connection                                                                                  \n         rcon = ibis.duckdb.connect()                                                                              \n                                                                                                                   \n         # create tables in read connection                                                                        \n         for table_name in wcon.list_tables():                                                                     \n             rcon.read_sqlite(self.dbpath, table_name=table_name)                                                  \n                                                                                                                   \n         return wcon, rcon                                                                                         \n                                                                                                                   \n     # tables                                                                                                      \n     def todos_t(self, user_id: str = None):                                                                       \n         # get todos data                                                                                          \n         t = self.rcon.table(self.todos_table_name)                                                                \n                                                                                                                   \n         # filter by user_id                                                                                       \n         if user_id:                                                                                               \n             t = t.filter(t[\"user_id\"] == user_id)                                                                 \n                                                                                                                   \n         # get only the latest metadata                                                                            \n         t = (                                                                                                     \n             t.mutate(                                                                                             \n                 rank=ibis.row_number().over(                                                                      \n                     ibis.window(                                                                                  \n                         group_by=\"id\",                                                                            \n                         order_by=ibis.desc(\"idx\"),                                                                \n                     )                                                                                             \n                 )                                                                                                 \n             )                                                                                                     \n             .filter(ibis._[\"rank\"] == 0)                                                                          \n             .drop(\"rank\")                                                                                         \n         )                                                                                                         \n                                                                                                                   \n         # comma-separated lists to arrays                                                                         \n         t = t.mutate(labels=t[\"labels\"].split(\",\"))                                                               \n                                                                                                                   \n         # order                                                                                                   \n         t = t.order_by(ibis.asc(\"priority\"), ibis.desc(\"idx\"))                                                    \n                                                                                                                   \n         # return the data                                                                                         \n         return t                                                                                                  \n                                                                                                                   \n     # contains                                                                                                    \n     def contains_todo(self, id: str, user_id: str = None) -&gt; bool:                                                \n         t = self.todos_t(user_id=user_id)                                                                         \n         return t.filter(t[\"id\"] == id).count().to_pyarrow().as_py() &gt; 0                                           \n                                                                                                                   \n     # get record                                                                                                  \n     def get_todos(self, user_id: str = None):                                                                     \n         t = self.todos_t(user_id=user_id)                                                                         \n                                                                                                                   \n         return t.to_pyarrow().to_pylist()                                                                         \n                                                                                                                   \n     def get_todo(self, id: str, user_id: str = None):                                                             \n         t = self.todos_t(user_id=user_id)                                                                         \n         return t.filter(t[\"id\"] == id).to_pyarrow().to_pylist()[0]                                                \n                                                                                                                   \n     # append record                                                                                               \n     def append_todo(                                                                                              \n         self,                                                                                                     \n         id: str,                                                                                                  \n         user_id: str,                                                                                             \n         subject: str,                                                                                             \n         body: str,                                                                                                \n         priority: int = 100,                                                                                      \n         status: str = None,                                                                                       \n         description: str = None,                                                                                  \n         labels: list[str] = None,                                                                                 \n     ):                                                                                                            \n         if self.contains_todo(id=id):                                                                             \n             raise ValueError(f\"todo {id} already exists\")                                                         \n                                                                                                                   \n         data = {                                                                                                  \n             \"idx\": [now()],                                                                                       \n             \"id\": [id],                                                                                           \n             \"user_id\": [user_id],                                                                                 \n             \"subject\": [subject],                                                                                 \n             \"body\": [body],                                                                                       \n             \"priority\": [priority],                                                                               \n             \"status\": [status],                                                                                   \n             \"description\": [description],                                                                         \n             \"labels\": [\",\".join(labels) if labels else None],                                                     \n         }                                                                                                         \n         self.wcon.insert(self.todos_table_name, data)                                                             \n                                                                                                                   \n         return self.get_todo(id=id)                                                                               \n                                                                                                                   \n     # update record                                                                                               \n     def update_todo(                                                                                              \n         self,                                                                                                     \n         id: str,                                                                                                  \n         user_id: str,                                                                                             \n         subject: str,                                                                                             \n         body: str,                                                                                                \n         priority: int = 100,                                                                                      \n         status: str = None,                                                                                       \n         description: str = None,                                                                                  \n         labels: list[str] = None,                                                                                 \n     ):                                                                                                            \n         if not self.contains_todo(id=id):                                                                         \n             raise ValueError(f\"todo {id} does not exist\")                                                         \n                                                                                                                   \n         data = {                                                                                                  \n             \"idx\": [now()],                                                                                       \n             \"id\": [id],                                                                                           \n             \"user_id\": [user_id],                                                                                 \n             \"subject\": [subject],                                                                                 \n             \"body\": [body],                                                                                       \n             \"priority\": [priority],                                                                               \n             \"status\": [status],                                                                                   \n             \"description\": [description],                                                                         \n             \"labels\": [\",\".join(labels) if labels else None],                                                     \n         }                                                                                                         \n         self.wcon.insert(self.todos_table_name, data)                                                             \n                                                                                                                   \n         return self.get_todo(id=id)                                                                               \n                                                                                                                   \n     # aliases                                                                                                     \n     __call__ = get_todos                                                                                          \n     t = todos_t                                                                                                   \n                                                                                                                   \n\n\n\nWe have a simple, fast, performant todo list.\n\n\ndkdc-lake\nLet’s look at dkdc-lake as another example:\n\nfrom dkdc_lake import Lake\n\nlake = Lake(dbpath=\"data.db\")\nlake\n\n&lt;dkdc_lake.main.Lake at 0x114296b70&gt;\n\n\nWe can again view the table/schema:\n\nlake.t()\n\n┏━━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n┃ idx          ┃ id     ┃ user_id ┃ path   ┃ filename ┃ filetype ┃ data   ┃ version ┃ status ┃ description ┃ labels        ┃\n┡━━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n│ timestamp(6) │ string │ string  │ string │ string   │ string   │ binary │ int64   │ string │ string      │ array&lt;string&gt; │\n└──────────────┴────────┴─────────┴────────┴──────────┴──────────┴────────┴─────────┴────────┴─────────────┴───────────────┘\n\n\n\nAnd append a record (representing a file) into it:\n\nlake.append_file(\n    user_id=None,\n    path=None,\n    filename=\"test.txt\",\n    filetype=\"txt\",\n    data=b\"hello world\",\n)\n\n{'idx': datetime.datetime(2024, 11, 25, 17, 8, 43, 569924),\n 'id': '173255452356992-bc5e9fe6',\n 'user_id': None,\n 'path': None,\n 'filename': 'test.txt',\n 'filetype': 'txt',\n 'data': b'hello world',\n 'version': None,\n 'status': None,\n 'description': None,\n 'labels': None}\n\n\nNow, we see our record:\n\nlake.t()\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┓\n┃ idx                        ┃ id                       ┃ user_id ┃ path   ┃ filename ┃ filetype ┃ data           ┃ version ┃ status ┃ description ┃ labels ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━┩\n│ timestamp(6)               │ string                   │ string  │ string │ string   │ string   │ binary         │ int64   │ string │ string      │ array… │\n├────────────────────────────┼──────────────────────────┼─────────┼────────┼──────────┼──────────┼────────────────┼─────────┼────────┼─────────────┼────────┤\n│ 2024-11-25 17:08:43.569924 │ 173255452356992-bc5e9fe6 │ NULL    │ NULL   │ test.txt │ txt      │ b'hello world' │    NULL │ NULL   │ NULL        │ NULL   │\n└────────────────────────────┴──────────────────────────┴─────────┴────────┴──────────┴──────────┴────────────────┴─────────┴────────┴─────────────┴────────┘\n\n\n\nAnd like before can update it:\n\nlake.update_file(\n    user_id=None,\n    path=None,\n    filename=\"test.txt\",\n    filetype=\"txt\",\n    data=b\"hello world!\",\n    version=None,\n    status=None,\n    description=None,\n    labels=None,\n)\n\n{'idx': datetime.datetime(2024, 11, 25, 17, 8, 43, 652484),\n 'id': '173255452356992-bc5e9fe6',\n 'user_id': None,\n 'path': None,\n 'filename': 'test.txt',\n 'filetype': 'txt',\n 'data': b'hello world!',\n 'version': None,\n 'status': None,\n 'description': None,\n 'labels': None}\n\n\nShowing only one row:\n\nlake.t()\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┓\n┃ idx                        ┃ id                       ┃ user_id ┃ path   ┃ filename ┃ filetype ┃ data            ┃ version ┃ status ┃ description ┃ labels ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━┩\n│ timestamp(6)               │ string                   │ string  │ string │ string   │ string   │ binary          │ int64   │ string │ string      │ array… │\n├────────────────────────────┼──────────────────────────┼─────────┼────────┼──────────┼──────────┼─────────────────┼─────────┼────────┼─────────────┼────────┤\n│ 2024-11-25 17:08:43.652484 │ 173255452356992-bc5e9fe6 │ NULL    │ NULL   │ test.txt │ txt      │ b'hello world!' │    NULL │ NULL   │ NULL        │ NULL   │\n└────────────────────────────┴──────────────────────────┴─────────┴────────┴──────────┴──────────┴─────────────────┴─────────┴────────┴─────────────┴────────┘\n\n\n\nBut again, there are two in the underlying SQLite table:\n\nlake.wcon.table(lake.lake_table_name)\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┓\n┃ idx                        ┃ id                       ┃ user_id ┃ path   ┃ filename ┃ filetype ┃ data            ┃ version ┃ status ┃ description ┃ labels ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━┩\n│ timestamp                  │ string                   │ string  │ string │ string   │ string   │ binary          │ int64   │ string │ string      │ string │\n├────────────────────────────┼──────────────────────────┼─────────┼────────┼──────────┼──────────┼─────────────────┼─────────┼────────┼─────────────┼────────┤\n│ 2024-11-25 17:08:43.569924 │ 173255452356992-bc5e9fe6 │ NULL    │ NULL   │ test.txt │ txt      │ b'hello world'  │    NULL │ NULL   │ NULL        │ NULL   │\n│ 2024-11-25 17:08:43.652484 │ 173255452356992-bc5e9fe6 │ NULL    │ NULL   │ test.txt │ txt      │ b'hello world!' │    NULL │ NULL   │ NULL        │ NULL   │\n└────────────────────────────┴──────────────────────────┴─────────┴────────┴──────────┴──────────┴─────────────────┴─────────┴────────┴─────────────┴────────┘\n\n\n\nOur view above is using a window function over idx (a timestamp) to take only the latest version of the record:\n\n\nLake class code code\nget_class_source(Lake)\n\n\n                                                                                                                   \n class Lake(State):                                                                                                \n     def __init__(self, dbpath: str = None):                                                                       \n         if dbpath is None:                                                                                        \n             dbpath = os.path.join(get_dkdc_dir(), \"lake.db\")                                                      \n         super().__init__(dbpath=dbpath)                                                                           \n                                                                                                                   \n     def _cons(self) -&gt; (ibis.BaseBackend, ibis.BaseBackend):                                                      \n         # create write connection                                                                                 \n         wcon = ibis.sqlite.connect(self.dbpath)                                                                   \n                                                                                                                   \n         # create tables in write connection                                                                       \n         ## lake data                                                                                              \n         self.lake_table_name = \"lake\"                                                                             \n         schema = ibis.schema(                                                                                     \n             {                                                                                                     \n                 \"idx\": dt.timestamp,                                                                              \n                 \"id\": str,                                                                                        \n                 \"user_id\": str,                                                                                   \n                 \"path\": str,                                                                                      \n                 \"filename\": str,                                                                                  \n                 \"filetype\": str,                                                                                  \n                 \"data\": dt.binary,                                                                                \n                 \"version\": int,                                                                                   \n                 \"status\": str,                                                                                    \n                 \"description\": str,                                                                               \n                 \"labels\": str,  # comma-separated list of labels                                                  \n             }                                                                                                     \n         )                                                                                                         \n         if self.lake_table_name not in wcon.list_tables():                                                        \n             wcon.create_table(self.lake_table_name, schema=schema)                                                \n                                                                                                                   \n         # create read connection                                                                                  \n         rcon = ibis.duckdb.connect()                                                                              \n                                                                                                                   \n         # create tables in read connection                                                                        \n         for table_name in wcon.list_tables():                                                                     \n             rcon.read_sqlite(self.dbpath, table_name=table_name)                                                  \n                                                                                                                   \n         return wcon, rcon                                                                                         \n                                                                                                                   \n     # tables                                                                                                      \n     def lake_t(self, user_id: str = None):                                                                        \n         # get lake data                                                                                           \n         t = self.rcon.table(self.lake_table_name)                                                                 \n                                                                                                                   \n         # filter by user_id                                                                                       \n         if user_id:                                                                                               \n             t = t.filter(t[\"user_id\"] == user_id)                                                                 \n                                                                                                                   \n         # get only the latest metadata                                                                            \n         t = (                                                                                                     \n             t.mutate(                                                                                             \n                 rank=ibis.row_number().over(                                                                      \n                     ibis.window(                                                                                  \n                         group_by=\"id\",                                                                            \n                         order_by=ibis.desc(\"idx\"),                                                                \n                     )                                                                                             \n                 )                                                                                                 \n             )                                                                                                     \n             .filter(ibis._[\"rank\"] == 0)                                                                          \n             .drop(\"rank\")                                                                                         \n         )                                                                                                         \n                                                                                                                   \n         # comma-separated lists to arrays                                                                         \n         t = t.mutate(labels=t[\"labels\"].split(\",\"))                                                               \n                                                                                                                   \n         # order                                                                                                   \n         t = t.order_by(ibis.desc(\"idx\"))                                                                          \n                                                                                                                   \n         # return the data                                                                                         \n         return t                                                                                                  \n                                                                                                                   \n     # contains                                                                                                    \n     def contains_path(self, path: str, user_id: str = None) -&gt; bool:                                              \n         t = self.lake_t(user_id=user_id)                                                                          \n         return t.filter(t[\"path\"] == path).count().to_pyarrow().as_py() &gt; 0                                       \n                                                                                                                   \n     def contains_file(                                                                                            \n         self, filename: str, path: str = None, user_id: str = None                                                \n     ) -&gt; bool:                                                                                                    \n         t = self.lake_t(user_id=user_id)                                                                          \n         return (                                                                                                  \n             t.filter((t[\"path\"] == path) & (t[\"filename\"] == filename))                                           \n             .count()                                                                                              \n             .to_pyarrow()                                                                                         \n             .as_py()                                                                                              \n             &gt; 0                                                                                                   \n         )                                                                                                         \n                                                                                                                   \n     # get record                                                                                                  \n     def get_file(self, filename: str, path: str = None, user_id: str = None):                                     \n         if not self.contains_file(filename=filename, path=path, user_id=user_id):                                 \n             raise ValueError(f\"File {filename} does not exist\")                                                   \n                                                                                                                   \n         t = self.lake_t(user_id=user_id)                                                                          \n         return (                                                                                                  \n             t.filter((t[\"path\"] == path) & (t[\"filename\"] == filename))                                           \n             .to_pyarrow()                                                                                         \n             .to_pylist()[0]                                                                                       \n         )                                                                                                         \n                                                                                                                   \n     # append record                                                                                               \n     def append_file(                                                                                              \n         self,                                                                                                     \n         user_id: str = None,                                                                                      \n         path: str = None,                                                                                         \n         filename: str = None,                                                                                     \n         filetype: str = None,                                                                                     \n         data: bytes = None,                                                                                       \n         version: int = None,                                                                                      \n         status: str = None,                                                                                       \n         description: str = None,                                                                                  \n         labels: list[str] = None,                                                                                 \n     ):                                                                                                            \n         assert (filename is not None) and (                                                                       \n             data is not None                                                                                      \n         ), \"user_id, filename, and data are required\"                                                             \n                                                                                                                   \n         if self.contains_file(filename=filename, path=path, user_id=user_id):                                     \n             raise ValueError(f\"File {filename} already exists\")                                                   \n                                                                                                                   \n         data = {                                                                                                  \n             \"idx\": [now()],                                                                                       \n             \"id\": [uuid()],                                                                                       \n             \"user_id\": [user_id],                                                                                 \n             \"path\": [path],                                                                                       \n             \"filename\": [filename],                                                                               \n             \"filetype\": [filetype],                                                                               \n             \"data\": [data],                                                                                       \n             \"version\": [version],                                                                                 \n             \"status\": [status],                                                                                   \n             \"description\": [description],                                                                         \n             \"labels\": [\",\".join(labels) if labels else None],                                                     \n         }                                                                                                         \n         self.wcon.insert(self.lake_table_name, data)                                                              \n                                                                                                                   \n         return self.get_file(filename=filename, path=path, user_id=user_id)                                       \n                                                                                                                   \n     # update record                                                                                               \n     def update_file(                                                                                              \n         self,                                                                                                     \n         user_id: str,                                                                                             \n         path: str,                                                                                                \n         filename: str,                                                                                            \n         filetype: str,                                                                                            \n         data: bytes,                                                                                              \n         version: int,                                                                                             \n         status: str,                                                                                              \n         description: str,                                                                                         \n         labels: list[str] = None,                                                                                 \n     ):                                                                                                            \n         if not self.contains_file(filename=filename, path=path, user_id=user_id):                                 \n             raise ValueError(f\"File {filename} does not exist\")                                                   \n                                                                                                                   \n         f = self.get_file(filename=filename, path=path, user_id=user_id)                                          \n         id = f[\"id\"]                                                                                              \n                                                                                                                   \n         data = {                                                                                                  \n             \"idx\": [now()],                                                                                       \n             \"id\": [id],                                                                                           \n             \"user_id\": [user_id],                                                                                 \n             \"path\": [path],                                                                                       \n             \"filename\": [filename],                                                                               \n             \"filetype\": [filetype],                                                                               \n             \"data\": [data],                                                                                       \n             \"version\": [version],                                                                                 \n             \"status\": [status],                                                                                   \n             \"description\": [description],                                                                         \n             \"labels\": [\",\".join(labels) if labels else None],                                                     \n         }                                                                                                         \n         self.wcon.insert(self.lake_table_name, data)                                                              \n                                                                                                                   \n         return self.get_file(filename=filename, path=path, user_id=user_id)                                       \n                                                                                                                   \n     # aliases                                                                                                     \n     __call__ = get_file                                                                                           \n     t = lake_t"
  },
  {
    "objectID": "posts/fast-simple-state/index.html#looking-ahead",
    "href": "posts/fast-simple-state/index.html#looking-ahead",
    "title": "fast, simple, persistent state management with Python (Ibis)",
    "section": "looking ahead",
    "text": "looking ahead\nI’m not really sure how well this works in practice at scale. I know I can process a few billion rows on my laptop with DuckDB, though that was on Parquet files and not views on top of SQLite tables. I’m not sure how well concurrent users writing to the same SQLite database will work. But it should be fine?\n\n\n\n\n\n\nCaution\n\n\n\nThis code is early and not the best. It will likely be improved over time. Check the respective repositories!\n\n\nMost importantly for dkdc-io, the user interface is simple and useful. The details can change behind the abstraction."
  }
]
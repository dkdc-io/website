[
  {
    "objectID": "posts/what-is-dkdc/index.html",
    "href": "posts/what-is-dkdc/index.html",
    "title": "launching ‘dkdc-io’",
    "section": "",
    "text": "A decade-long journey back home.\nNearly a decade ago, I started “DKDC LLC” not far from where I am today."
  },
  {
    "objectID": "posts/what-is-dkdc/index.html#why-dkdc",
    "href": "posts/what-is-dkdc/index.html#why-dkdc",
    "title": "launching ‘dkdc-io’",
    "section": "why “DKDC”?",
    "text": "why “DKDC”?\nI didn’t need to start a company, but I wanted to. I was working with a local company to prototype a device for testing in a hospital. Ostensibly a limited liability company (LLC) would limit my liability, but there was effectively no risk in my work. The real appeal was in learning the process and being able to say “I started a company”.\n\n“I started a company!”\n“Oh yeah? What’s it called?”\n“DKDC LLC.”\n“What does DKDC stand for?”\n“Don’t know, don’t care.”"
  },
  {
    "objectID": "posts/what-is-dkdc/index.html#branding",
    "href": "posts/what-is-dkdc/index.html#branding",
    "title": "launching ‘dkdc-io’",
    "section": "branding",
    "text": "branding\nMy full name is relatively common and I found “dkdc” to be a useful, unique suffix for online accounts. It’s bland, neutral, and doesn’t really mean anything. It was a good fit a decade ago for a company that didn’t really do anything and it’s been a good fit since for my usernames and personal branding since.\n\n\n\n\n\n\nWarning\n\n\n\n\n\n“dkdc” is very difficult to understand over the phone."
  },
  {
    "objectID": "posts/what-is-dkdc/index.html#starting-dkdc-io",
    "href": "posts/what-is-dkdc/index.html#starting-dkdc-io",
    "title": "launching ‘dkdc-io’",
    "section": "starting “dkdc-io”",
    "text": "starting “dkdc-io”\n\n“reincarnated”\n\nAs of publishing this post, “dkdc-io” is nothing more than an idea and a GitHub organization with some nascent code. It’s intended as a bland, neutral, and unassuming home for useful code that can do things for me (and perhaps others). Software for me. A startup in a box. A decade of learnings?"
  },
  {
    "objectID": "posts/fast-simple-python/index.html",
    "href": "posts/fast-simple-python/index.html",
    "title": "fast, full-stack Python (uv & Docker)",
    "section": "",
    "text": "Using uv and Docker to develop and deploy simple, scalable, full-stack Python applications.\n\nIn this post, we’ll look at my Dockerfile:\n# dkdc Dockerfile\nFROM ghcr.io/astral-sh/uv:latest AS uv\nFROM python:3.12-slim\n# set the environment variables\nENV PATH=/root/.local/bin:$PATH\n# set the working directory\nWORKDIR /app\n# copy the files\nCOPY readme.md /app/readme.md\nCOPY pyproject.toml /app/pyproject.toml\nCOPY src /app/src\n# install the Python packages\nRUN --mount=type=cache,target=/root/.cache/uv \\\n    --mount=from=uv,source=/uv,target=./uv \\\n    ./uv pip install '.' --system --upgrade\nI use it to develop simple, scalable, full-stack Python applications built with:\n\nTyper: CLI\nIbis: table management and queries\n\nSQLite and/or Postgres: OLTP database\nDuckDB: OLAP database (views on top of the OLTP tables)\n\nShiny for Python: GUI\n\nPlotly: plots\n\n\nThen, deploy them with ease (and minimal build times) locally, on a Raspberry Pi, and on a cloud VM. Of course, other open source software and Python packages are used along the way (and you can use whatever you like!).\nSome miscellaneous notes:\n\norder: the Dockefile is ordered so that frequently changing parts are toward the bottom\ncache: the big point is the caching line, which I stole from somewhere (here?)\nreadme.md: the pyproject.toml is needed as it defines the installation of the package (and CLI), and the readme.md is needed because it’s referenced in the pyproject.toml\nsrc: this is the source code, in something like src/my_package, and obviously needs to be copied\npinning verions: in general I’m not pinning (or using a uv lockfile), but I would obviously recommend doing so for production workloads and having a process for updating dependencies\nsystem installation: we use system Python instead of creating a Python virtual environment (which uv makes easy) because we’re already in a virtual container (often itself in a virtual machine)\n\nCombining this with a few justfile commands makes development and deployment very easy. The simplicity of Python and tools that cover the full stack (CLI, database, GUI) make it a great choice for rapidly prototyping scalable applications.\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "dkdc.io",
    "section": "",
    "text": "Code by Cody.\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "about",
    "section": "",
    "text": "Things built for people.\nThe dkdc-io organization on GitHub was created in November 2024 to consolidate useful code in a free and open source manner.\nThe goals of our projects include:\nThese goals are largely achieved through the use of simplicity, Python, and “AI”."
  },
  {
    "objectID": "about.html#views-on-ai",
    "href": "about.html#views-on-ai",
    "title": "about",
    "section": "views on “AI”",
    "text": "views on “AI”\nArtificial intelligence (“AI”) is a science fiction (and now popular culture) term that anamorphosizes the reality of computers. Reframing language models as string processors that operate in useful ways simplifies the dynamic drastically.\n\nUser:\n“I want the phrase: ‘we often ____ AI as if it were human’, what’s the term?”\nChatGPT:\n“The term you’re looking for is ‘anthropomorphize’.\nSo the phrase would be: ‘We often anthropomorphize AI as if it were human.’”\n\nTechnology is good. I strongly prefer you send your code in a GitHub pull request from a computer rather than a fax of a print out from your typerwriter. In either case, if you can’t vouch for the work you’re publishing, you’re doing it wrong.\n\nlanguage models and Python (and SQL)\nAbstractions: vim is a lot nicer than punching cards. Working with high-level programming languages is typically a lot more productive than working with assembly, though there will always be a place for programming languages at all levels of abstraction. For working with data (and machine learning), Python is a great choice and the clear winner by popularity (+ SQL)."
  },
  {
    "objectID": "about.html#views-on-simplicity",
    "href": "about.html#views-on-simplicity",
    "title": "about",
    "section": "views on simplicity",
    "text": "views on simplicity\nPython and SQL are arguably ubiquitous because of their simplicity. Both allow novice users to accomplish non-trivial work with minimal effort, while experienced professionals can use them to build complex systems."
  },
  {
    "objectID": "about.html#the-python-tech-stack",
    "href": "about.html#the-python-tech-stack",
    "title": "about",
    "section": "the Python tech stack",
    "text": "the Python tech stack\nPython is the user interface for programming at every level of the tech stack.\nFor now, this includes:\n\nTyper: CLI\nFastAPI: web server + continuous data ingestion and ETL (cron jobs)\nIbis: table management and queries\n\nSQLite and/or Postgres: OLTP database\nDuckDB: OLAP database (views on top of the OLTP tables)\n\nQuarto: website (static)\nShiny for Python: web app\n\nMeta-tools:\n\nuv: Python management\njustfile: task management\nDocker and Docker Compose: containerization\n\nInfrastructure:\n\nGitHub: code, CI/CD, etc.\nTBD: cloud provider (currently using raspberry pis and GCP)"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "posts",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nfast, simple, persistent state management with Python (Ibis)\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\nNov 26, 2024\n\n\nCody\n\n\n\n\n\n\n\n\n\n\n\n\nfast, full-stack Python (uv & Docker)\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\nNov 25, 2024\n\n\nCody\n\n\n\n\n\n\n\n\n\n\n\n\nlaunching ‘dkdc-io’\n\n\n\n\n\n\ndkdc-io\n\n\n\n\n\n\n\n\n\nNov 24, 2024\n\n\nCody\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "website",
    "section": "",
    "text": "website\nhttps://dkdc.io.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/fast-simple-state/index.html",
    "href": "posts/fast-simple-state/index.html",
    "title": "fast, simple, persistent state management with Python (Ibis)",
    "section": "",
    "text": "Using SQLite and DuckDB (via Ibis) to manage perisistent state in Python."
  },
  {
    "objectID": "posts/fast-simple-state/index.html#dkdc-state",
    "href": "posts/fast-simple-state/index.html#dkdc-state",
    "title": "fast, simple, persistent state management with Python (Ibis)",
    "section": "dkdc-state",
    "text": "dkdc-state\nIn this post, we’ll look at the what and why of dkdc-state:\n\nfrom dkdc_state import State, ibis\n\nibis.options.interactive = True\n\nstate = State()\nstate._clear() # for demonstration purposes, clear all tables\nstate\n\n&lt;dkdc_state.main.State at 0x107ed6ab0&gt;\n\n\nThe State class itself isn’t very interesting, but we extend it to implement a number of other stateful Python libraries. Looking at the source code:\n\n\nState class code code\nfrom website.utils import get_class_source\n\nget_class_source(State)\n\n\n                                                                                                                   \n class State:                                                                                                      \n     # initialization                                                                                              \n     def __init__(self, dbpath: str = \"data.db\"):                                                                  \n         self.dbpath = dbpath                                                                                      \n                                                                                                                   \n         self.wcon, self.rcon = self._cons()                                                                       \n                                                                                                                   \n     # reference implementation -- to be overridden                                                                \n     def _cons(self) -&gt; (ibis.BaseBackend, ibis.BaseBackend):                                                      \n         # create write connection                                                                                 \n         wcon = ibis.sqlite.connect(self.dbpath)                                                                   \n                                                                                                                   \n         # create tables in write connection                                                                       \n         ...                                                                                                       \n                                                                                                                   \n         # create read connection                                                                                  \n         rcon = ibis.duckdb.connect()                                                                              \n                                                                                                                   \n         # create tables in read connection                                                                        \n         for table_name in wcon.list_tables():                                                                     \n             rcon.read_sqlite(self.dbpath, table_name=table_name)                                                  \n                                                                                                                   \n         # return connections                                                                                      \n         return wcon, rcon                                                                                         \n                                                                                                                   \n     def _clear(self, table_names: str | list[str] = None):                                                        \n         # if table_names is None, clear all tables                                                                \n         table_names = self.wcon.list_tables() if table_names is None else table_names                             \n                                                                                                                   \n         # if table_names is a string, convert to a list                                                           \n         if isinstance(table_names, str):                                                                          \n             table_names = [table_names]                                                                           \n                                                                                                                   \n         # drop views and tables                                                                                   \n         for table_name in table_names:                                                                            \n             self.rcon.drop_view(table_name)                                                                       \n             self.wcon.drop_table(table_name)                                                                      \n                                                                                                                   \n         # reset connections (recreate tables)                                                                     \n         self.wcon, self.rcon = self._cons()                                                                       \n                                                                                                                   \n\n\n\nWe define a __init__ method that calls a _cons method that sets up a write connection (SQLite) and read connection (DuckDB) with Ibis. A standard _clear method is defined to drop the tables (and corresponding views). That’s it!\nTo create a fast, simple, persistent state management system we simply need to extend the State class, implement the table creation in the _cons method, and add methods to interact with the state.\n\ndkdc-todo\nLet’s look at dkdc-todo as an example:\n\nfrom dkdc_todo import Todo\n\ntodo = Todo(dbpath=\"data.db\")\ntodo\n\n&lt;dkdc_todo.main.Todo at 0x11732a180&gt;\n\n\nWe can view the table (and thus the schema):\n\ntodo.t()\n\n┏━━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n┃ idx          ┃ id     ┃ user_id ┃ subject ┃ body   ┃ priority ┃ status ┃ description ┃ labels        ┃\n┡━━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n│ timestamp(6) │ string │ string  │ string  │ string │ int64    │ string │ string      │ array&lt;string&gt; │\n└──────────────┴────────┴─────────┴─────────┴────────┴──────────┴────────┴─────────────┴───────────────┘\n\n\n\nThen append items to the table:\n\ntodo.append_todo(id=\"test\", user_id=None, subject=None, body=\"do your homework\")\n\n{'idx': datetime.datetime(2024, 11, 25, 17, 8, 43, 385111),\n 'id': 'test',\n 'user_id': None,\n 'subject': None,\n 'body': 'do your homework',\n 'priority': 100,\n 'status': None,\n 'description': None,\n 'labels': None}\n\n\nAt this point we see our record:\n\ntodo.t()\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┓\n┃ idx                        ┃ id     ┃ user_id ┃ subject ┃ body             ┃ priority ┃ status ┃ description ┃ labels ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━┩\n│ timestamp(6)               │ string │ string  │ string  │ string           │ int64    │ string │ string      │ array… │\n├────────────────────────────┼────────┼─────────┼─────────┼──────────────────┼──────────┼────────┼─────────────┼────────┤\n│ 2024-11-25 17:08:43.385111 │ test   │ NULL    │ NULL    │ do your homework │      100 │ NULL   │ NULL        │ NULL   │\n└────────────────────────────┴────────┴─────────┴─────────┴──────────────────┴──────────┴────────┴─────────────┴────────┘\n\n\n\nImportantly, dkdc-state tables are intended to be append-only. Once append_* (confusingly named here) is called, you must use update_* to update the record (with the same id).\nTo demonstrate this, let’s update that record:\n\ntodo.update_todo(id=\"test\", user_id=None, subject=None, body=\"do your homework!\")\n\n{'idx': datetime.datetime(2024, 11, 25, 17, 8, 43, 436369),\n 'id': 'test',\n 'user_id': None,\n 'subject': None,\n 'body': 'do your homework!',\n 'priority': 100,\n 'status': None,\n 'description': None,\n 'labels': None}\n\n\nThen view our table:\n\ntodo.t()\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┓\n┃ idx                        ┃ id     ┃ user_id ┃ subject ┃ body              ┃ priority ┃ status ┃ description ┃ labels ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━┩\n│ timestamp(6)               │ string │ string  │ string  │ string            │ int64    │ string │ string      │ array… │\n├────────────────────────────┼────────┼─────────┼─────────┼───────────────────┼──────────┼────────┼─────────────┼────────┤\n│ 2024-11-25 17:08:43.436369 │ test   │ NULL    │ NULL    │ do your homework! │      100 │ NULL   │ NULL        │ NULL   │\n└────────────────────────────┴────────┴─────────┴─────────┴───────────────────┴──────────┴────────┴─────────────┴────────┘\n\n\n\nThere’s only 1 row! The second rows is in there, the table code is just set to only show the latest version of each record.\nLet’s look at the underlying table:\n\ntodo.wcon.table(todo.todos_table_name)\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┓\n┃ idx                        ┃ id     ┃ user_id ┃ subject ┃ body              ┃ priority ┃ status ┃ description ┃ labels ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━┩\n│ timestamp                  │ string │ string  │ string  │ string            │ int64    │ string │ string      │ string │\n├────────────────────────────┼────────┼─────────┼─────────┼───────────────────┼──────────┼────────┼─────────────┼────────┤\n│ 2024-11-25 17:08:43.385111 │ test   │ NULL    │ NULL    │ do your homework  │      100 │ NULL   │ NULL        │ NULL   │\n│ 2024-11-25 17:08:43.436369 │ test   │ NULL    │ NULL    │ do your homework! │      100 │ NULL   │ NULL        │ NULL   │\n└────────────────────────────┴────────┴─────────┴─────────┴───────────────────┴──────────┴────────┴─────────────┴────────┘\n\n\n\nAnd we see both rows. You can add other convenience methods to the state class as needed:\n\ntodo.get_todo(id=\"test\")\n\n{'idx': datetime.datetime(2024, 11, 25, 17, 8, 43, 436369),\n 'id': 'test',\n 'user_id': None,\n 'subject': None,\n 'body': 'do your homework!',\n 'priority': 100,\n 'status': None,\n 'description': None,\n 'labels': None}\n\n\nTaking a look at the source code:\n\n\nTodo class code code\nget_class_source(Todo)\n\n\n                                                                                                                   \n class Todo(State):                                                                                                \n     def __init__(self, dbpath: str = None):                                                                       \n         if dbpath is None:                                                                                        \n             dbpath = os.path.join(get_dkdc_dir(), \"todo.db\")                                                      \n         super().__init__(dbpath=dbpath)                                                                           \n                                                                                                                   \n     def _cons(self) -&gt; (ibis.BaseBackend, ibis.BaseBackend):                                                      \n         # create write connection                                                                                 \n         wcon = ibis.sqlite.connect(self.dbpath)                                                                   \n                                                                                                                   \n         # create tables in write connection                                                                       \n         ## todos data                                                                                             \n         self.todos_table_name = \"todos\"                                                                           \n         schema = ibis.schema(                                                                                     \n             {                                                                                                     \n                 \"idx\": dt.timestamp,                                                                              \n                 \"id\": str,                                                                                        \n                 \"user_id\": str,                                                                                   \n                 \"subject\": str,                                                                                   \n                 \"body\": str,                                                                                      \n                 \"priority\": int,                                                                                  \n                 \"status\": str,                                                                                    \n                 \"description\": str,                                                                               \n                 \"labels\": str,  # comma-separated list of labels                                                  \n             }                                                                                                     \n         )                                                                                                         \n         if self.todos_table_name not in wcon.list_tables():                                                       \n             wcon.create_table(self.todos_table_name, schema=schema)                                               \n                                                                                                                   \n         # create read connection                                                                                  \n         rcon = ibis.duckdb.connect()                                                                              \n                                                                                                                   \n         # create tables in read connection                                                                        \n         for table_name in wcon.list_tables():                                                                     \n             rcon.read_sqlite(self.dbpath, table_name=table_name)                                                  \n                                                                                                                   \n         return wcon, rcon                                                                                         \n                                                                                                                   \n     # tables                                                                                                      \n     def todos_t(self, user_id: str = None):                                                                       \n         # get todos data                                                                                          \n         t = self.rcon.table(self.todos_table_name)                                                                \n                                                                                                                   \n         # filter by user_id                                                                                       \n         if user_id:                                                                                               \n             t = t.filter(t[\"user_id\"] == user_id)                                                                 \n                                                                                                                   \n         # get only the latest metadata                                                                            \n         t = (                                                                                                     \n             t.mutate(                                                                                             \n                 rank=ibis.row_number().over(                                                                      \n                     ibis.window(                                                                                  \n                         group_by=\"id\",                                                                            \n                         order_by=ibis.desc(\"idx\"),                                                                \n                     )                                                                                             \n                 )                                                                                                 \n             )                                                                                                     \n             .filter(ibis._[\"rank\"] == 0)                                                                          \n             .drop(\"rank\")                                                                                         \n         )                                                                                                         \n                                                                                                                   \n         # comma-separated lists to arrays                                                                         \n         t = t.mutate(labels=t[\"labels\"].split(\",\"))                                                               \n                                                                                                                   \n         # order                                                                                                   \n         t = t.order_by(ibis.asc(\"priority\"), ibis.desc(\"idx\"))                                                    \n                                                                                                                   \n         # return the data                                                                                         \n         return t                                                                                                  \n                                                                                                                   \n     # contains                                                                                                    \n     def contains_todo(self, id: str, user_id: str = None) -&gt; bool:                                                \n         t = self.todos_t(user_id=user_id)                                                                         \n         return t.filter(t[\"id\"] == id).count().to_pyarrow().as_py() &gt; 0                                           \n                                                                                                                   \n     # get record                                                                                                  \n     def get_todos(self, user_id: str = None):                                                                     \n         t = self.todos_t(user_id=user_id)                                                                         \n                                                                                                                   \n         return t.to_pyarrow().to_pylist()                                                                         \n                                                                                                                   \n     def get_todo(self, id: str, user_id: str = None):                                                             \n         t = self.todos_t(user_id=user_id)                                                                         \n         return t.filter(t[\"id\"] == id).to_pyarrow().to_pylist()[0]                                                \n                                                                                                                   \n     # append record                                                                                               \n     def append_todo(                                                                                              \n         self,                                                                                                     \n         id: str,                                                                                                  \n         user_id: str,                                                                                             \n         subject: str,                                                                                             \n         body: str,                                                                                                \n         priority: int = 100,                                                                                      \n         status: str = None,                                                                                       \n         description: str = None,                                                                                  \n         labels: list[str] = None,                                                                                 \n     ):                                                                                                            \n         if self.contains_todo(id=id):                                                                             \n             raise ValueError(f\"todo {id} already exists\")                                                         \n                                                                                                                   \n         data = {                                                                                                  \n             \"idx\": [now()],                                                                                       \n             \"id\": [id],                                                                                           \n             \"user_id\": [user_id],                                                                                 \n             \"subject\": [subject],                                                                                 \n             \"body\": [body],                                                                                       \n             \"priority\": [priority],                                                                               \n             \"status\": [status],                                                                                   \n             \"description\": [description],                                                                         \n             \"labels\": [\",\".join(labels) if labels else None],                                                     \n         }                                                                                                         \n         self.wcon.insert(self.todos_table_name, data)                                                             \n                                                                                                                   \n         return self.get_todo(id=id)                                                                               \n                                                                                                                   \n     # update record                                                                                               \n     def update_todo(                                                                                              \n         self,                                                                                                     \n         id: str,                                                                                                  \n         user_id: str,                                                                                             \n         subject: str,                                                                                             \n         body: str,                                                                                                \n         priority: int = 100,                                                                                      \n         status: str = None,                                                                                       \n         description: str = None,                                                                                  \n         labels: list[str] = None,                                                                                 \n     ):                                                                                                            \n         if not self.contains_todo(id=id):                                                                         \n             raise ValueError(f\"todo {id} does not exist\")                                                         \n                                                                                                                   \n         data = {                                                                                                  \n             \"idx\": [now()],                                                                                       \n             \"id\": [id],                                                                                           \n             \"user_id\": [user_id],                                                                                 \n             \"subject\": [subject],                                                                                 \n             \"body\": [body],                                                                                       \n             \"priority\": [priority],                                                                               \n             \"status\": [status],                                                                                   \n             \"description\": [description],                                                                         \n             \"labels\": [\",\".join(labels) if labels else None],                                                     \n         }                                                                                                         \n         self.wcon.insert(self.todos_table_name, data)                                                             \n                                                                                                                   \n         return self.get_todo(id=id)                                                                               \n                                                                                                                   \n     # aliases                                                                                                     \n     __call__ = get_todos                                                                                          \n     t = todos_t                                                                                                   \n                                                                                                                   \n\n\n\nWe have a simple, fast, performant todo list.\n\n\ndkdc-lake\nLet’s look at dkdc-lake as another example:\n\nfrom dkdc_lake import Lake\n\nlake = Lake(dbpath=\"data.db\")\nlake\n\n&lt;dkdc_lake.main.Lake at 0x114296b70&gt;\n\n\nWe can again view the table/schema:\n\nlake.t()\n\n┏━━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n┃ idx          ┃ id     ┃ user_id ┃ path   ┃ filename ┃ filetype ┃ data   ┃ version ┃ status ┃ description ┃ labels        ┃\n┡━━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n│ timestamp(6) │ string │ string  │ string │ string   │ string   │ binary │ int64   │ string │ string      │ array&lt;string&gt; │\n└──────────────┴────────┴─────────┴────────┴──────────┴──────────┴────────┴─────────┴────────┴─────────────┴───────────────┘\n\n\n\nAnd append a record (representing a file) into it:\n\nlake.append_file(\n    user_id=None,\n    path=None,\n    filename=\"test.txt\",\n    filetype=\"txt\",\n    data=b\"hello world\",\n)\n\n{'idx': datetime.datetime(2024, 11, 25, 17, 8, 43, 569924),\n 'id': '173255452356992-bc5e9fe6',\n 'user_id': None,\n 'path': None,\n 'filename': 'test.txt',\n 'filetype': 'txt',\n 'data': b'hello world',\n 'version': None,\n 'status': None,\n 'description': None,\n 'labels': None}\n\n\nNow, we see our record:\n\nlake.t()\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┓\n┃ idx                        ┃ id                       ┃ user_id ┃ path   ┃ filename ┃ filetype ┃ data           ┃ version ┃ status ┃ description ┃ labels ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━┩\n│ timestamp(6)               │ string                   │ string  │ string │ string   │ string   │ binary         │ int64   │ string │ string      │ array… │\n├────────────────────────────┼──────────────────────────┼─────────┼────────┼──────────┼──────────┼────────────────┼─────────┼────────┼─────────────┼────────┤\n│ 2024-11-25 17:08:43.569924 │ 173255452356992-bc5e9fe6 │ NULL    │ NULL   │ test.txt │ txt      │ b'hello world' │    NULL │ NULL   │ NULL        │ NULL   │\n└────────────────────────────┴──────────────────────────┴─────────┴────────┴──────────┴──────────┴────────────────┴─────────┴────────┴─────────────┴────────┘\n\n\n\nAnd like before can update it:\n\nlake.update_file(\n    user_id=None,\n    path=None,\n    filename=\"test.txt\",\n    filetype=\"txt\",\n    data=b\"hello world!\",\n    version=None,\n    status=None,\n    description=None,\n    labels=None,\n)\n\n{'idx': datetime.datetime(2024, 11, 25, 17, 8, 43, 652484),\n 'id': '173255452356992-bc5e9fe6',\n 'user_id': None,\n 'path': None,\n 'filename': 'test.txt',\n 'filetype': 'txt',\n 'data': b'hello world!',\n 'version': None,\n 'status': None,\n 'description': None,\n 'labels': None}\n\n\nShowing only one row:\n\nlake.t()\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┓\n┃ idx                        ┃ id                       ┃ user_id ┃ path   ┃ filename ┃ filetype ┃ data            ┃ version ┃ status ┃ description ┃ labels ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━┩\n│ timestamp(6)               │ string                   │ string  │ string │ string   │ string   │ binary          │ int64   │ string │ string      │ array… │\n├────────────────────────────┼──────────────────────────┼─────────┼────────┼──────────┼──────────┼─────────────────┼─────────┼────────┼─────────────┼────────┤\n│ 2024-11-25 17:08:43.652484 │ 173255452356992-bc5e9fe6 │ NULL    │ NULL   │ test.txt │ txt      │ b'hello world!' │    NULL │ NULL   │ NULL        │ NULL   │\n└────────────────────────────┴──────────────────────────┴─────────┴────────┴──────────┴──────────┴─────────────────┴─────────┴────────┴─────────────┴────────┘\n\n\n\nBut again, there are two in the underlying SQLite table:\n\nlake.wcon.table(lake.lake_table_name)\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┓\n┃ idx                        ┃ id                       ┃ user_id ┃ path   ┃ filename ┃ filetype ┃ data            ┃ version ┃ status ┃ description ┃ labels ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━┩\n│ timestamp                  │ string                   │ string  │ string │ string   │ string   │ binary          │ int64   │ string │ string      │ string │\n├────────────────────────────┼──────────────────────────┼─────────┼────────┼──────────┼──────────┼─────────────────┼─────────┼────────┼─────────────┼────────┤\n│ 2024-11-25 17:08:43.569924 │ 173255452356992-bc5e9fe6 │ NULL    │ NULL   │ test.txt │ txt      │ b'hello world'  │    NULL │ NULL   │ NULL        │ NULL   │\n│ 2024-11-25 17:08:43.652484 │ 173255452356992-bc5e9fe6 │ NULL    │ NULL   │ test.txt │ txt      │ b'hello world!' │    NULL │ NULL   │ NULL        │ NULL   │\n└────────────────────────────┴──────────────────────────┴─────────┴────────┴──────────┴──────────┴─────────────────┴─────────┴────────┴─────────────┴────────┘\n\n\n\nOur view above is using a window function over idx (a timestamp) to take only the latest version of the record:\n\n\nLake class code code\nget_class_source(Lake)\n\n\n                                                                                                                   \n class Lake(State):                                                                                                \n     def __init__(self, dbpath: str = None):                                                                       \n         if dbpath is None:                                                                                        \n             dbpath = os.path.join(get_dkdc_dir(), \"lake.db\")                                                      \n         super().__init__(dbpath=dbpath)                                                                           \n                                                                                                                   \n     def _cons(self) -&gt; (ibis.BaseBackend, ibis.BaseBackend):                                                      \n         # create write connection                                                                                 \n         wcon = ibis.sqlite.connect(self.dbpath)                                                                   \n                                                                                                                   \n         # create tables in write connection                                                                       \n         ## lake data                                                                                              \n         self.lake_table_name = \"lake\"                                                                             \n         schema = ibis.schema(                                                                                     \n             {                                                                                                     \n                 \"idx\": dt.timestamp,                                                                              \n                 \"id\": str,                                                                                        \n                 \"user_id\": str,                                                                                   \n                 \"path\": str,                                                                                      \n                 \"filename\": str,                                                                                  \n                 \"filetype\": str,                                                                                  \n                 \"data\": dt.binary,                                                                                \n                 \"version\": int,                                                                                   \n                 \"status\": str,                                                                                    \n                 \"description\": str,                                                                               \n                 \"labels\": str,  # comma-separated list of labels                                                  \n             }                                                                                                     \n         )                                                                                                         \n         if self.lake_table_name not in wcon.list_tables():                                                        \n             wcon.create_table(self.lake_table_name, schema=schema)                                                \n                                                                                                                   \n         # create read connection                                                                                  \n         rcon = ibis.duckdb.connect()                                                                              \n                                                                                                                   \n         # create tables in read connection                                                                        \n         for table_name in wcon.list_tables():                                                                     \n             rcon.read_sqlite(self.dbpath, table_name=table_name)                                                  \n                                                                                                                   \n         return wcon, rcon                                                                                         \n                                                                                                                   \n     # tables                                                                                                      \n     def lake_t(self, user_id: str = None):                                                                        \n         # get lake data                                                                                           \n         t = self.rcon.table(self.lake_table_name)                                                                 \n                                                                                                                   \n         # filter by user_id                                                                                       \n         if user_id:                                                                                               \n             t = t.filter(t[\"user_id\"] == user_id)                                                                 \n                                                                                                                   \n         # get only the latest metadata                                                                            \n         t = (                                                                                                     \n             t.mutate(                                                                                             \n                 rank=ibis.row_number().over(                                                                      \n                     ibis.window(                                                                                  \n                         group_by=\"id\",                                                                            \n                         order_by=ibis.desc(\"idx\"),                                                                \n                     )                                                                                             \n                 )                                                                                                 \n             )                                                                                                     \n             .filter(ibis._[\"rank\"] == 0)                                                                          \n             .drop(\"rank\")                                                                                         \n         )                                                                                                         \n                                                                                                                   \n         # comma-separated lists to arrays                                                                         \n         t = t.mutate(labels=t[\"labels\"].split(\",\"))                                                               \n                                                                                                                   \n         # order                                                                                                   \n         t = t.order_by(ibis.desc(\"idx\"))                                                                          \n                                                                                                                   \n         # return the data                                                                                         \n         return t                                                                                                  \n                                                                                                                   \n     # contains                                                                                                    \n     def contains_path(self, path: str, user_id: str = None) -&gt; bool:                                              \n         t = self.lake_t(user_id=user_id)                                                                          \n         return t.filter(t[\"path\"] == path).count().to_pyarrow().as_py() &gt; 0                                       \n                                                                                                                   \n     def contains_file(                                                                                            \n         self, filename: str, path: str = None, user_id: str = None                                                \n     ) -&gt; bool:                                                                                                    \n         t = self.lake_t(user_id=user_id)                                                                          \n         return (                                                                                                  \n             t.filter((t[\"path\"] == path) & (t[\"filename\"] == filename))                                           \n             .count()                                                                                              \n             .to_pyarrow()                                                                                         \n             .as_py()                                                                                              \n             &gt; 0                                                                                                   \n         )                                                                                                         \n                                                                                                                   \n     # get record                                                                                                  \n     def get_file(self, filename: str, path: str = None, user_id: str = None):                                     \n         if not self.contains_file(filename=filename, path=path, user_id=user_id):                                 \n             raise ValueError(f\"File {filename} does not exist\")                                                   \n                                                                                                                   \n         t = self.lake_t(user_id=user_id)                                                                          \n         return (                                                                                                  \n             t.filter((t[\"path\"] == path) & (t[\"filename\"] == filename))                                           \n             .to_pyarrow()                                                                                         \n             .to_pylist()[0]                                                                                       \n         )                                                                                                         \n                                                                                                                   \n     # append record                                                                                               \n     def append_file(                                                                                              \n         self,                                                                                                     \n         user_id: str = None,                                                                                      \n         path: str = None,                                                                                         \n         filename: str = None,                                                                                     \n         filetype: str = None,                                                                                     \n         data: bytes = None,                                                                                       \n         version: int = None,                                                                                      \n         status: str = None,                                                                                       \n         description: str = None,                                                                                  \n         labels: list[str] = None,                                                                                 \n     ):                                                                                                            \n         assert (filename is not None) and (                                                                       \n             data is not None                                                                                      \n         ), \"user_id, filename, and data are required\"                                                             \n                                                                                                                   \n         if self.contains_file(filename=filename, path=path, user_id=user_id):                                     \n             raise ValueError(f\"File {filename} already exists\")                                                   \n                                                                                                                   \n         data = {                                                                                                  \n             \"idx\": [now()],                                                                                       \n             \"id\": [uuid()],                                                                                       \n             \"user_id\": [user_id],                                                                                 \n             \"path\": [path],                                                                                       \n             \"filename\": [filename],                                                                               \n             \"filetype\": [filetype],                                                                               \n             \"data\": [data],                                                                                       \n             \"version\": [version],                                                                                 \n             \"status\": [status],                                                                                   \n             \"description\": [description],                                                                         \n             \"labels\": [\",\".join(labels) if labels else None],                                                     \n         }                                                                                                         \n         self.wcon.insert(self.lake_table_name, data)                                                              \n                                                                                                                   \n         return self.get_file(filename=filename, path=path, user_id=user_id)                                       \n                                                                                                                   \n     # update record                                                                                               \n     def update_file(                                                                                              \n         self,                                                                                                     \n         user_id: str,                                                                                             \n         path: str,                                                                                                \n         filename: str,                                                                                            \n         filetype: str,                                                                                            \n         data: bytes,                                                                                              \n         version: int,                                                                                             \n         status: str,                                                                                              \n         description: str,                                                                                         \n         labels: list[str] = None,                                                                                 \n     ):                                                                                                            \n         if not self.contains_file(filename=filename, path=path, user_id=user_id):                                 \n             raise ValueError(f\"File {filename} does not exist\")                                                   \n                                                                                                                   \n         f = self.get_file(filename=filename, path=path, user_id=user_id)                                          \n         id = f[\"id\"]                                                                                              \n                                                                                                                   \n         data = {                                                                                                  \n             \"idx\": [now()],                                                                                       \n             \"id\": [id],                                                                                           \n             \"user_id\": [user_id],                                                                                 \n             \"path\": [path],                                                                                       \n             \"filename\": [filename],                                                                               \n             \"filetype\": [filetype],                                                                               \n             \"data\": [data],                                                                                       \n             \"version\": [version],                                                                                 \n             \"status\": [status],                                                                                   \n             \"description\": [description],                                                                         \n             \"labels\": [\",\".join(labels) if labels else None],                                                     \n         }                                                                                                         \n         self.wcon.insert(self.lake_table_name, data)                                                              \n                                                                                                                   \n         return self.get_file(filename=filename, path=path, user_id=user_id)                                       \n                                                                                                                   \n     # aliases                                                                                                     \n     __call__ = get_file                                                                                           \n     t = lake_t"
  },
  {
    "objectID": "posts/fast-simple-state/index.html#looking-ahead",
    "href": "posts/fast-simple-state/index.html#looking-ahead",
    "title": "fast, simple, persistent state management with Python (Ibis)",
    "section": "looking ahead",
    "text": "looking ahead\nI’m not really sure how well this works in practice at scale. I know I can process a few billion rows on my laptop with DuckDB, though that was on Parquet files and not views on top of SQLite tables. I’m not sure how well concurrent users writing to the same SQLite database will work. But it should be fine?\n\n\n\n\n\n\nCaution\n\n\n\nThis code is early and not the best. It will likely be improved over time. Check the respective repositories!\n\n\nMost importantly for dkdc-io, the user interface is simple and useful. The details can change behind the abstraction."
  }
]